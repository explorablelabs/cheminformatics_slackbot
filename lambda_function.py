import os
import json
import logging
import hashlib
import hmac
from botocore.vendored import requests
import json

# Grab the signing secret from the environment so we can ensure this request came from the app we expect.
slack_signing_secret = os.environ["SIGNING_SECRET"]

# Send our replies to the targeted Slack resource.
webhook_url = 'https://hooks.slack.com/services/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'

logger = logging.getLogger()
logger.setLevel(logging.WARNING)

def verify_slack_request(slack_signature=None, slack_request_timestamp=None, request_body=None):
    '''
    The steps here are outlined in the Slack docs - check for our signing secret in the message.
    '''
    basestring = f"v0:{slack_request_timestamp}:{request_body}".encode('utf-8')

    # Make the Signing Secret a bytestring too.
    slack_signing_secret_bytes = bytes(slack_signing_secret, 'utf-8')

    #Create a new HMAC "signature", and return the string presentation.
    my_signature = 'v0=' + hmac.new(slack_signing_secret_bytes, basestring, hashlib.sha256).hexdigest()

    ''' Compare the the Slack provided signature to ours.
    If they are equal, the request should be verified successfully.
    Log the unsuccessful requests for further analysis. '''
    if hmac.compare_digest(my_signature, slack_signature):
        return True
    else:
        logger.warning(f"Verification failed. my_signature: {my_signature}")
        return False


''' Process the POST request from API Gateway proxy integration. '''
def post(event, context):
    '''
    
    '''
    try:

        ''' Verify the request. '''
        slack_signature = event['headers']['X-Slack-Signature']
        slack_request_timestamp = event['headers']['X-Slack-Request-Timestamp']
        if not verify_slack_request(slack_signature, slack_request_timestamp, event['body']):
            logger.info('Bad request.')
            response = {
                "status_code": 400,
                "body": ''
            }
            return response
        else:
            # Send 200 response so Slack knows we received the message, then continue processing
            # (If we take too long to respond, Slack may re-send the request.)
            response = requests.post(
                webhook_url, json={"status_code": 200, "body": ''},
                headers={'Content-Type': 'application/json'}
            )

        body = event["body"]
        parsed_body = json.loads(body)
        this_event = parsed_body["event"]
        text = this_event["text"]
        
        # Get chemical descriptors of text, if possible
        apiurl = 'https://api.explorablelabs.com/descriptors/smiles/' + text
        headers = {'Content-Type': 'application/json'}
        r = requests.get(apiurl, headers=headers)
        logger.info(r.text) # Can view response from API in Cloudwatch logs
        
        if "Internal Server Error" in r.text:
            descriptor_text = "Not a valid SMILES string!"
        else:
            #Nicely format descriptors for return response
            descriptors_dict = json.loads(r.text)
            descriptor_text = ""
            for descriptor in descriptors_dict:
                descriptor_text += "*%s:* " % descriptor
                descriptor_text += str(descriptors_dict[descriptor]) + "\n"
        
        response = requests.post(
            webhook_url, json={"text": descriptor_text},
            headers={'Content-Type': 'application/json'}
        )
        logger.info(response.status_code) # Non-200 status_code = problem
        return response.status_code

    except Exception as e:
        ''' Just a stub. ERROR: messages can be viewed in the Cloudwatch logs'''
        logger.error(f"ERROR: {e}")
        response = {
            "status_code": 200,
            "body": ''
        }
        return response

def lambda_handler(data, context):
    """Handle an incoming HTTP request from a Slack chat-bot.
    """
    
    body = data["body"]
    parsed_body = json.loads(body)
    
    # The challenge field is used by Slack to verify the bot
    if "challenge" in parsed_body:
        response = {
            "status_code": 200,
            "body": parsed_body["challenge"]
        }
        return response

    # Grab the Slack event data.
    slack_event = parsed_body['event']
    
    # We need to discriminate between events generated by 
    # the users, which we want to process and handle, 
    # and those generated by the bot.
    if "bot_id" in slack_event:
        logging.warn("Ignore bot event")
    else:
        post(data, context)
        
    response = {
        "status_code": 200,
        "body": ''
    }
    return response
    
